/**
 * Macro Master (by Tomof) ‚Äî Cloudflare Worker (service-worker syntax)
 *
 * ‚úÖ Fixed assets only (no manual ticker)
 * ‚úÖ Reply Keyboard toggleable (shows as ‚¨ú‚¨ú button in Telegram)
 * ‚úÖ Always: 3‚Äì5 days, Trader, Extended
 * ‚úÖ No tables / no sources block
 * ‚úÖ Removes Perplexity citations like [1][2]
 * ‚úÖ Forces clean Telegram structure (headers never glue to previous text)
 * ‚úÖ Anti-truncation: END marker + continuation call (NO stop param)
 * ‚úÖ KV rate limit (TTL >= 60)
 *
 * REQUIRED BINDINGS:
 *   KV Namespace binding: BOT_KV
 *
 * REQUIRED SECRETS:
 *   TELEGRAM_BOT_TOKEN
 *   PERPLEXITY_API_KEY
 *
 * OPTIONAL:
 *   PERPLEXITY_MODEL        (default: "sonar-pro")
 *   REQUEST_TIMEOUT         (ms, default: 25000)
 *   RATE_LIMIT_SECONDS      (default: 20)
 *   TELEGRAM_WEBHOOK_SECRET (optional)
 */

addEventListener("fetch", (event) => {
  event.respondWith(handleFetch(event.request, event));
});

const TG_API = "https://api.telegram.org/bot";
const PPLX_API = "https://api.perplexity.ai/chat/completions";
const PARSE_MODE = undefined;

/* =======================
   Assets
======================= */
const ASSETS = [
  { label: "SP500", ticker: "^GSPC", style: "INDEX" },
  { label: "NASDAQ", ticker: "^NDX", style: "INDEX" },
  { label: "UKX", ticker: "^FTSE", style: "INDEX" },
  { label: "DAX", ticker: "^GDAXI", style: "INDEX" },
  { label: "EUR", ticker: "EURUSD", style: "FX" },
  { label: "GBP", ticker: "GBPUSD", style: "FX" },
  { label: "TLT", ticker: "TLT", style: "INDEX" },
  { label: "VIX", ticker: "^VIX", style: "INDEX" },
  { label: "GOLD", ticker: "XAUUSD", style: "INDEX" },
  { label: "SILVER", ticker: "XAGUSD", style: "INDEX" }
];

const ASSET_MAP = (() => {
  const m = Object.create(null);
  for (const a of ASSETS) m[a.label.toLowerCase()] = a;
  return m;
})();

/* =======================
   Reply Keyboard (toggleable via ‚¨ú‚¨ú)
======================= */
function assetsReplyKeyboard() {
  return {
    keyboard: [
      [{ text: "SP500" }, { text: "NASDAQ" }],
      [{ text: "UKX" }, { text: "DAX" }],
      [{ text: "EUR" }, { text: "GBP" }],
      [{ text: "TLT" }, { text: "VIX" }],
      [{ text: "GOLD" }, { text: "SILVER" }]
    ],
    resize_keyboard: true,
    one_time_keyboard: false,
    input_field_placeholder: "–í—ã–±–µ—Ä–∏ –∞–∫—Ç–∏–≤"
  };
}

/* =======================
   Fetch / Webhook
======================= */
async function handleFetch(req, event) {
  if (req.method === "GET") {
    const url = new URL(req.url);
    if (url.pathname === "/health") return new Response("OK", { status: 200 });
    return new Response("OK", { status: 200 });
  }

  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const secret = (globalThis.TELEGRAM_WEBHOOK_SECRET || "").trim();
  if (secret) {
    const hdr = req.headers.get("X-Telegram-Bot-Api-Secret-Token");
    if (hdr !== secret) return new Response("Forbidden", { status: 403 });
  }

  let update;
  try {
    update = await req.json();
  } catch {
    return new Response("Bad Request", { status: 400 });
  }

  event.waitUntil(handleUpdate(update));
  return new Response("OK", { status: 200 });
}

/* =======================
   Update Router
======================= */
async function handleUpdate(update) {
  try {
    if (!update.message) return;
    await onMessage(update.message);
  } catch (e) {
    const chatId = update?.message?.chat?.id;
    if (chatId) {
      await tgSendMessage(chatId, `‚ö†Ô∏è –û—à–∏–±–∫–∞: ${String(e?.message || e)}`, assetsReplyKeyboard());
    }
  }
}

/* =======================
   Message handler
======================= */
async function onMessage(msg) {
  const chatId = msg.chat.id;
  const userId = msg.from?.id;
  const textRaw = (msg.text || "").trim();
  const text = textRaw.toLowerCase();

  if (!userId) return;

  // /start and /analyze just show keyboard, no extra texts
  if (text === "/start" || text === "/analyze" || text === "/analyse") {
    return tgSendMessage(chatId, " ", assetsReplyKeyboard());
  }

  // pressed asset button
  const asset = ASSET_MAP[text];
  if (!asset) {
    return tgSendMessage(chatId, "–í—ã–±–µ—Ä–∏ –∞–∫—Ç–∏–≤ –∫–Ω–æ–ø–∫–æ–π –Ω–∏–∂–µ.", assetsReplyKeyboard());
  }

  if (!(await checkRateLimit(userId))) {
    return tgSendMessage(chatId, "–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ.", assetsReplyKeyboard());
  }

  const report = await runAnalysis(asset);
  return tgSendLong(chatId, report);
}

/* =======================
   Rate limit (KV)
======================= */
function rlKey(uid) {
  return `rl:${uid}`;
}

async function checkRateLimit(uid) {
  const limit = parseInt(globalThis.RATE_LIMIT_SECONDS || "20", 10);
  const now = Date.now();

  const last = await BOT_KV.get(rlKey(uid));
  if (last && now - Number(last) < limit * 1000) return false;

  await BOT_KV.put(rlKey(uid), String(now), { expirationTtl: Math.max(60, limit + 10) });
  return true;
}

/* =======================
   Perplexity analysis
======================= */
async function runAnalysis(asset) {
  const timeoutMs = parseInt(globalThis.REQUEST_TIMEOUT || "25000", 10);
  const model = String(globalThis.PERPLEXITY_MODEL || "sonar-pro").trim();

  const controller = new AbortController();
  const to = setTimeout(() => controller.abort("timeout"), timeoutMs);

  try {
    const prompt = buildPrompt(asset);

    // Primary answer
    let text = await askPerplexity({
      model,
      prompt,
      maxTokens: 900,
      signal: controller.signal
    });

    // If END missing -> continuation (cheap)
    if (!hasEndMarker(text)) {
      const cont = await askPerplexity({
        model,
        prompt:
          "–ü—Ä–æ–¥–æ–ª–∂–∏ —Å—Ç—Ä–æ–≥–æ —Å –º–µ—Å—Ç–∞ –æ–±—Ä—ã–≤–∞. –ù–µ –ø–æ–≤—Ç–æ—Ä—è–π —É–∂–µ –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–µ. " +
          "–ù–µ –¥–æ–±–∞–≤–ª—è–π –Ω–æ–≤—ã—Ö —Ä–∞–∑–¥–µ–ª–æ–≤. –ó–∞–≤–µ—Ä—à–∏ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Å—Ç—Ä–æ–∫–∏ –∏ –∑–∞–∫–æ–Ω—á–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π END.\n\n" +
          "–û–¢–†–´–í–û–ö (–æ–±—Ä–µ–∑–∞–Ω):\n" +
          text,
        maxTokens: 320,
        signal: controller.signal
      });
      text = mergeContinuation(text, cont);
    }

    // Cleanup + enforce structure
    let out = text;
    out = removeEndMarker(out);
    out = cleanText(out);
    out = fixStructure(out);

    if (!out) return "–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.";
    return out;
  } catch (e) {
    const msg = String(e?.message || e);
    if (msg.includes("timeout") || msg.includes("Abort")) return "–¢–∞–π–º–∞—É—Ç Perplexity. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.";
    return "–û—à–∏–±–∫–∞ Perplexity: " + msg;
  } finally {
    clearTimeout(to);
  }
}

async function askPerplexity({ model, prompt, maxTokens, signal }) {
  if (!globalThis.PERPLEXITY_API_KEY) throw new Error("PERPLEXITY_API_KEY is not set");

  const body = {
    model,
    messages: [
      {
        role: "system",
        content:
          "–¢—ã –º–∞–∫—Ä–æ-—Å—Ç—Ä–∞—Ç–µ–≥. –ü–∏—à–∏ —Å—Ç—Ä–æ–≥–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. " +
          "–ë–µ–∑ —Ç–∞–±–ª–∏—Ü, —Å—Å—ã–ª–æ–∫, –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –∏ –±–µ–∑ –∞–Ω–≥–ª–∏—Ü–∏–∑–º–æ–≤. " +
          "–ë–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (**/__/*/`). " +
          "–ö–∞–∂–¥—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–∞–∑–¥–µ–ª–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ –∏ –ø–µ—Ä–µ–¥ –Ω–∏–º –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞. " +
          "–í –∫–æ–Ω—Ü–µ –≤—Å–µ–≥–¥–∞ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ END."
      },
      { role: "user", content: prompt }
    ],
    temperature: 0.2,
    top_p: 0.9,
    max_tokens: maxTokens,
    search_context_size: "low"
  };

  const res = await fetch(PPLX_API, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${PERPLEXITY_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body),
    signal
  });

  const txt = await res.text();
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${txt}`);

  let data = {};
  try {
    data = JSON.parse(txt);
  } catch {
    throw new Error("Perplexity returned non-JSON response");
  }

  const content = data?.choices?.[0]?.message?.content || data?.output_text || "";
  return String(content || "").trim();
}

/* =======================
   Prompt
======================= */
function buildPrompt(asset) {
  const styleRule =
    asset.style === "FX"
      ? "FX: –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª —Å—Ç–∞–≤–æ–∫/–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π, –¥–æ–ª–ª–∞—Ä –°–®–ê, –∞–ø–ø–µ—Ç–∏—Ç –∫ —Ä–∏—Å–∫—É."
      : "INDEX: —Ä–µ–∞–ª—å–Ω—ã–µ —Å—Ç–∞–≤–∫–∏/–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏, –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ —Å—Ç–∞–≤–∫–∞–º –§–†–°, —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è, –¥–æ–ª–ª–∞—Ä.";

  return `
–ê–∫—Ç–∏–≤: ${asset.label} (${asset.ticker})
–ì–æ—Ä–∏–∑–æ–Ω—Ç: 3‚Äì5 –¥–Ω–µ–π
–†–µ–∂–∏–º: Trader

–í–ê–ñ–ù–û:
- –ü–∏—à–∏ —Ç–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º, –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
- –ö–∞–∂–¥—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ ‚Äî —Å—Ç—Ä–æ–≥–æ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.
- –ü–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –∑–∞–≥–æ–ª–æ–≤–∫–æ–º (üî•/üìä/üéØ/‚ö†Ô∏è/üß†) —Å—Ç–∞–≤—å –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É.
- –ù–∏–∫–æ–≥–¥–∞ –Ω–µ —Å—Ç–∞–≤—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ –∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ—Å–ª–µ —Ç–µ–∫—Å—Ç–∞.

${styleRule}

–°–¢–†–£–ö–¢–£–†–ê (—Å—Ç—Ä–æ–≥–æ):

üî• –ö–õ–Æ–ß–ï–í–´–ï –°–û–ë–´–¢–ò–Ø
‚Ä¢ 2‚Äì3 –ø—É–Ω–∫—Ç–∞, –ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

üìä –ú–ê–ö–†–û-–ö–û–ù–¢–ï–ö–°–¢
‚Ä¢ 2‚Äì3 –∫–ª—é—á–µ–≤—ã—Ö —Ç–µ–∑–∏—Å–∞, –ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

üéØ –°–¶–ï–ù–ê–†–ò–ò
Base: —É—Å–ª–æ–≤–∏–µ ‚Üí —Ä–µ–∞–∫—Ü–∏—è ‚Üí –ø—Ä–∏—á–∏–Ω–∞
Bull: —É—Å–ª–æ–≤–∏–µ ‚Üí —Ä–µ–∞–∫—Ü–∏—è ‚Üí –ø—Ä–∏—á–∏–Ω–∞
Bear: —É—Å–ª–æ–≤–∏–µ ‚Üí —Ä–µ–∞–∫—Ü–∏—è ‚Üí –ø—Ä–∏—á–∏–Ω–∞

‚ö†Ô∏è –†–ò–°–ö–ò
‚Ä¢ 3‚Äì4 –ø—É–Ω–∫—Ç–∞, –ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

üß† TL;DR
‚Ä¢ 2‚Äì3 –ø—É–Ω–∫—Ç–∞, –ø–æ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ

–í –∫–æ–Ω—Ü–µ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: END
`.trim();
}

/* =======================
   Structure & cleanup
======================= */
function hasEndMarker(s) {
  const t = String(s || "").trimEnd();
  return t.endsWith("\nEND") || t.endsWith("END");
}

function removeEndMarker(s) {
  let t = String(s || "");
  t = t.replace(/\nEND\s*$/g, "");
  t = t.replace(/^END\s*$/g, "");
  return t.trim();
}

function mergeContinuation(a, b) {
  const x = String(a || "").trimEnd();
  const y = String(b || "").trim();
  if (!y) return x;
  return x + "\n" + y;
}

function cleanText(t) {
  let out = String(t || "");

  // Remove markdown artifacts
  out = out.split("**").join("");
  out = out.split("__").join("");
  out = out.split("*").join("");
  out = out.split("`").join("");

  // Remove Perplexity citation markers like [1], [12], etc.
  out = out.replace(/\[\d+\]/g, "");

  // Normalize spaces & newlines
  out = out.replace(/\s{2,}/g, " ");
  out = out.replace(/\n{3,}/g, "\n\n");
  out = out.trim();

  return out;
}

function fixStructure(text) {
  let t = String(text || "");

  const headers = [
    "üî• –ö–õ–Æ–ß–ï–í–´–ï –°–û–ë–´–¢–ò–Ø",
    "üìä –ú–ê–ö–†–û-–ö–û–ù–¢–ï–ö–°–¢",
    "üéØ –°–¶–ï–ù–ê–†–ò–ò",
    "‚ö†Ô∏è –†–ò–°–ö–ò",
    "üß† TL;DR"
  ];

  // Ensure blank line before headers (if glued to previous sentence)
  for (let i = 0; i < headers.length; i++) {
    const h = headers[i];
    const re = new RegExp(`([^\\n])\\s*${escapeRegExp(h)}`, "g");
    t = t.replace(re, `$1\n\n${h}`);
  }

  // Ensure newline after header
  for (let i = 0; i < headers.length; i++) {
    const h = headers[i];
    const re = new RegExp(`${escapeRegExp(h)}\\s*`, "g");
    t = t.replace(re, `${h}\n`);
  }

  // Make sure bullets start on new lines
  t = t.replace(/[ \t]*‚Ä¢[ \t]*/g, "‚Ä¢ ");

  // Tighten: remove trailing spaces per line
  t = t
    .split("\n")
    .map((line) => line.trimEnd())
    .join("\n");

  // Collapse excessive newlines
  t = t.replace(/\n{3,}/g, "\n\n").trim();

  return t;
}

function escapeRegExp(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

/* =======================
   Telegram API
======================= */
async function tgSendMessage(chatId, text, keyboard) {
  const token = globalThis.TELEGRAM_BOT_TOKEN;
  if (!token) throw new Error("TELEGRAM_BOT_TOKEN is not set");

  return fetch(`${TG_API}${token}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      parse_mode: PARSE_MODE,
      disable_web_page_preview: true,
      reply_markup: keyboard
    })
  });
}

async function tgSendLong(chatId, text) {
  const parts = splitTelegram(text, 3500);
  for (let i = 0; i < parts.length; i++) {
    await tgSendMessage(chatId, parts[i], assetsReplyKeyboard());
  }
}

function splitTelegram(text, maxLen) {
  const out = [];
  let t = String(text || "");

  while (t.length > maxLen) {
    let cut = t.lastIndexOf("\n", maxLen);
    if (cut < 1000) cut = maxLen;
    out.push(t.slice(0, cut));
    t = t.slice(cut);
  }
  if (t.trim()) out.push(t);
  return out;
}
