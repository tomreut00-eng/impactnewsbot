/**
 * Telegram Macro Analyzer Bot ‚Äî Cloudflare Worker (service-worker syntax)
 *
 * ‚úÖ Fixed assets only (no manual ticker)
 * ‚úÖ No menus, no inline buttons
 * ‚úÖ Bottom Reply Keyboard with assets (always visible)
 * ‚úÖ Always: 3‚Äì5 days, Trader, Extended
 * ‚úÖ Macro-context: only 2‚Äì3 theses
 * ‚úÖ Anti-truncation: END marker + fallback continuation call (NO stop param)
 * ‚úÖ KV rate-limit
 * ‚úÖ Plain text only (no parse_mode)
 *
 * REQUIRED BINDINGS:
 *   KV Namespace binding: BOT_KV
 *
 * REQUIRED SECRETS:
 *   TELEGRAM_BOT_TOKEN
 *   PERPLEXITY_API_KEY
 *
 * OPTIONAL:
 *   PERPLEXITY_MODEL        (default: "sonar-pro")
 *   REQUEST_TIMEOUT         (ms, default: 25000)
 *   RATE_LIMIT_SECONDS      (default: 20)   // KV TTL >= 60 is enforced
 *   TELEGRAM_WEBHOOK_SECRET (optional)
 */

addEventListener("fetch", (event) => {
  event.respondWith(handleFetch(event.request, event));
});

const PERPLEXITY_URL = "https://api.perplexity.ai/chat/completions";
const PARSE_MODE = undefined; // plain text only

const ASSETS = [
  { label: "SP500", ticker: "^GSPC", style: "INDEX" },
  { label: "NASDAQ", ticker: "^NDX", style: "INDEX" },
  { label: "UKX", ticker: "^FTSE", style: "INDEX" },
  { label: "DAX", ticker: "^GDAXI", style: "INDEX" },
  { label: "EUR", ticker: "EURUSD", style: "FX" },
  { label: "GBP", ticker: "GBPUSD", style: "FX" },
  { label: "TLT", ticker: "TLT", style: "INDEX" },
  { label: "VIX", ticker: "^VIX", style: "INDEX" },
  { label: "GOLD", ticker: "XAUUSD", style: "INDEX" },
  { label: "SILVER", ticker: "XAGUSD", style: "INDEX" }
];

const ASSET_MAP = (() => {
  const m = Object.create(null);
  for (const a of ASSETS) m[a.label.toLowerCase()] = a;
  return m;
})();

function assetsReplyKeyboard() {
  return {
    keyboard: [
      [{ text: "SP500" }, { text: "NASDAQ" }],
      [{ text: "UKX" }, { text: "DAX" }],
      [{ text: "EUR" }, { text: "GBP" }],
      [{ text: "TLT" }, { text: "VIX" }],
      [{ text: "GOLD" }, { text: "SILVER" }]
    ],
    resize_keyboard: true,
    is_persistent: true,
    one_time_keyboard: false
  };
}

/* =========================
   Fetch / webhook
========================= */
async function handleFetch(req, event) {
  if (req.method === "GET") {
    const url = new URL(req.url);
    if (url.pathname === "/health") return new Response("OK", { status: 200 });
    return new Response("OK", { status: 200 });
  }

  if (req.method !== "POST") return new Response("Method Not Allowed", { status: 405 });

  const secret = (globalThis.TELEGRAM_WEBHOOK_SECRET || "").trim();
  if (secret) {
    const hdr = req.headers.get("X-Telegram-Bot-Api-Secret-Token");
    if (hdr !== secret) return new Response("Forbidden", { status: 403 });
  }

  let update;
  try {
    update = await req.json();
  } catch {
    return new Response("Bad Request", { status: 400 });
  }

  event.waitUntil(handleUpdate(update));
  return new Response("OK", { status: 200 });
}

async function handleUpdate(update) {
  try {
    if (update.message) return await onMessage(update.message);
  } catch (e) {
    const chatId = update && update.message && update.message.chat && update.message.chat.id;
    if (chatId) {
      await tgSendMessage(
        chatId,
        `‚ö†Ô∏è –û—à–∏–±–∫–∞: ${String(e && e.message ? e.message : e)}`,
        PARSE_MODE,
        assetsReplyKeyboard()
      );
    }
  }
}

/* =========================
   Telegram messages
========================= */
async function onMessage(msg) {
  const chatId = msg.chat.id;
  const userId = msg.from && msg.from.id;
  const textRaw = (msg.text || "").trim();
  const text = textRaw.toLowerCase();

  if (!userId) return;

  // /start and /analyze just show keyboard, no extra texts
  if (text === "/start" || text === "/analyze" || text === "/analyse") {
    await touchUser(userId);
    return tgSendMessage(chatId, " ", PARSE_MODE, assetsReplyKeyboard());
  }

  // pressed asset button
  const asset = ASSET_MAP[text];
  if (asset) {
    if (!(await checkRateLimit(userId))) {
      return tgSendMessage(chatId, "–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ. –ü–æ–¥–æ–∂–¥–∏ –Ω–µ–º–Ω–æ–≥–æ.", PARSE_MODE, assetsReplyKeyboard());
    }

    const out = await runMacroAnalysis(asset);
    return tgSendLongMessage(chatId, out);
  }

  return tgSendMessage(chatId, "–í—ã–±–µ—Ä–∏ –∞–∫—Ç–∏–≤ –∫–Ω–æ–ø–∫–æ–π —Å–Ω–∏–∑—É.", PARSE_MODE, assetsReplyKeyboard());
}

/* =========================
   KV: touch + rate limit
========================= */
function userKey(userId) { return "u:" + userId + ":touch"; }
function rlKey(userId) { return "u:" + userId + ":rl"; }

async function touchUser(userId) {
  await BOT_KV.put(userKey(userId), String(Date.now()), { expirationTtl: 60 * 60 * 24 * 7 });
}

async function checkRateLimit(userId) {
  const n = parseInt(globalThis.RATE_LIMIT_SECONDS || "20", 10);
  const now = Date.now();

  const raw = await BOT_KV.get(rlKey(userId));
  if (raw) {
    const last = parseInt(raw, 10);
    if (!Number.isNaN(last) && now - last < n * 1000) return false;
  }

  const ttl = Math.max(60, n + 30);
  await BOT_KV.put(rlKey(userId), String(now), { expirationTtl: ttl });
  return true;
}

/* =========================
   Perplexity (anti-truncation WITHOUT stop)
========================= */
async function runMacroAnalysis(asset) {
  const timeoutMs = parseInt(globalThis.REQUEST_TIMEOUT || "25000", 10);
  const model = String(globalThis.PERPLEXITY_MODEL || "sonar-pro").trim();

  const horizon = "3‚Äì5 –¥–Ω–µ–π";
  const prompt = buildPrompt(asset.label, asset.ticker, horizon, asset.style);

  const controller = new AbortController();
  const to = setTimeout(() => controller.abort("timeout"), timeoutMs);

  try {
    // 1) Primary response (bigger to avoid truncation)
    let text = await perplexityAsk({
      model,
      prompt,
      signal: controller.signal,
      maxTokens: 900
    });

    // 2) If END missing -> continuation (cheap)
    if (!hasEndMarker(text)) {
      const cont = await perplexityContinue({
        model,
        originalPrompt: prompt,
        partialAnswer: text,
        signal: controller.signal,
        maxTokens: 320
      });
      text = mergeContinuation(text, cont);
    }

    // Cleanup + remove END
    let out = normalizeForTelegram(text);
    out = removeEndMarker(out);
    out = ruCleanup(out);
    out = stripFormattingArtifacts(out);

    if (!out) return "–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.";
    return out;
  } catch (e) {
    const msg = String(e && e.message ? e.message : e);
    if (msg.indexOf("timeout") >= 0 || msg.indexOf("Abort") >= 0) {
      return "–¢–∞–π–º–∞—É—Ç Perplexity. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.";
    }
    return "–û—à–∏–±–∫–∞ Perplexity: " + msg;
  } finally {
    clearTimeout(to);
  }
}

function hasEndMarker(s) {
  const t = String(s || "").trimEnd();
  return t.endsWith("\nEND") || t.endsWith("END");
}

function removeEndMarker(s) {
  let t = String(s || "");
  // remove trailing END line if present
  t = t.replace(/\nEND\s*$/g, "");
  t = t.replace(/^END\s*$/g, "");
  return t.trim();
}

function mergeContinuation(first, second) {
  const a = String(first || "").trimEnd();
  let b = String(second || "").trim();
  if (!b) return a;

  // If continuation starts with duplicated headers, try to avoid repeating too much
  // but keep it simple: just append.
  return a + "\n" + b;
}

async function perplexityAsk(opts) {
  const apiKey = globalThis.PERPLEXITY_API_KEY;
  if (!apiKey) throw new Error("PERPLEXITY_API_KEY is not set");

  const body = {
    model: opts.model,
    messages: [
      {
        role: "system",
        content:
          "–¢—ã –º–∞–∫—Ä–æ-—Å—Ç—Ä–∞—Ç–µ–≥. –ü–∏—à–∏ –∫—Ä–∞—Ç–∫–æ, –ø–æ –¥–µ–ª—É, –Ω–∞ —Ä—É—Å—Å–∫–æ–º. " +
          "–ë–µ–∑ —Ç–∞–±–ª–∏—Ü/—Å—Å—ã–ª–æ–∫/–∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤. –ë–µ–∑ –∞–Ω–≥–ª–∏—Ü–∏–∑–º–æ–≤. –ë–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. " +
          "–í–°–ï–ì–î–ê –∑–∞–∫–∞–Ω—á–∏–≤–∞–π –æ—Ç–≤–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π: END."
      },
      { role: "user", content: opts.prompt }
    ],
    temperature: 0.2,
    top_p: 0.9,
    max_tokens: opts.maxTokens || 900,
    // –¥–µ—à–µ–≤–ª–µ –∏ —Å—Ç–∞–±–∏–ª—å–Ω–µ–µ: –º–∞–ª–µ–Ω—å–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–∏—Å–∫–∞
    search_context_size: "low"
  };

  const res = await fetch(PERPLEXITY_URL, {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body),
    signal: opts.signal
  });

  if (!res.ok) {
    const txt = await safeText(res);
    throw new Error("HTTP " + res.status + ": " + (txt || res.statusText));
  }

  const data = await res.json().catch(() => ({}));
  const content =
    (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ||
    data.output_text ||
    "";

  return String(content || "").trim();
}

async function perplexityContinue(opts) {
  const apiKey = globalThis.PERPLEXITY_API_KEY;
  if (!apiKey) throw new Error("PERPLEXITY_API_KEY is not set");

  const body = {
    model: opts.model,
    messages: [
      {
        role: "system",
        content:
          "–¢—ã –º–∞–∫—Ä–æ-—Å—Ç—Ä–∞—Ç–µ–≥. –ü—Ä–æ–¥–æ–ª–∂–∞–π —Å—Ç—Ä–æ–≥–æ —Å –º–µ—Å—Ç–∞ –æ–±—Ä—ã–≤–∞. " +
          "–ù–µ –ø–æ–≤—Ç–æ—Ä—è–π —É–∂–µ –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–µ. –ù–µ –¥–æ–±–∞–≤–ª—è–π –Ω–æ–≤—ã–µ —Ä–∞–∑–¥–µ–ª—ã. " +
          "–î–æ–≤–µ–¥–∏ –¥–æ –∫–æ–Ω—Ü–∞ –≤—Å–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –ø—É–Ω–∫—Ç—ã. " +
          "–ü–∏—à–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. " +
          "–í–°–ï–ì–î–ê –∑–∞–∫–∞–Ω—á–∏–≤–∞–π –æ—Ç–¥–µ–ª—å–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π: END."
      },
      {
        role: "user",
        content:
          "–ò—Å—Ö–æ–¥–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:\n" +
          opts.originalPrompt +
          "\n\n–û–¢–†–´–í–û–ö –û–¢–í–ï–¢–ê (–æ–±—Ä–µ–∑–∞–Ω):\n" +
          opts.partialAnswer +
          "\n\n–ü—Ä–æ–¥–æ–ª–∂–∏ —Å –º–µ—Å—Ç–∞ –æ–±—Ä—ã–≤–∞ –∏ –∑–∞–≤–µ—Ä—à–∏. –í –∫–æ–Ω—Ü–µ –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ END."
      }
    ],
    temperature: 0.2,
    top_p: 0.9,
    max_tokens: opts.maxTokens || 320,
    search_context_size: "low"
  };

  const res = await fetch(PERPLEXITY_URL, {
    method: "POST",
    headers: {
      "Authorization": "Bearer " + apiKey,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body),
    signal: opts.signal
  });

  if (!res.ok) {
    const txt = await safeText(res);
    throw new Error("HTTP " + res.status + ": " + (txt || res.statusText));
  }

  const data = await res.json().catch(() => ({}));
  const content =
    (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ||
    data.output_text ||
    "";

  return String(content || "").trim();
}

function buildPrompt(assetLabel, ticker, horizon, style) {
  const styleRule =
    style === "FX"
      ? "FX: –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏–∞–ª —Å—Ç–∞–≤–æ–∫/–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π, –¥–æ–ª–ª–∞—Ä –°–®–ê, –∞–ø–ø–µ—Ç–∏—Ç –∫ —Ä–∏—Å–∫—É."
      : "INDEX: —Ä–µ–∞–ª—å–Ω—ã–µ —Å—Ç–∞–≤–∫–∏/–¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏, –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ —Å—Ç–∞–≤–∫–∞–º –§–†–°, —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è, –¥–æ–ª–ª–∞—Ä.";

  return [
    "–ü–∏—à–∏ –°–¢–†–û–ì–û –Ω–∞ —Ö–æ—Ä–æ—à–µ–º —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ, –æ–±—ã—á–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º.",
    "–õ—é–±–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–æ: –Ω–∏–∫–∞–∫–∏—Ö **, __, *, `.",
    "–ó–∞–ø—Ä–µ—â–µ–Ω—ã –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ —Å–ª–æ–≤–∞/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—ã.",
    "–ë–µ–∑ —Ç–∞–±–ª–∏—Ü, —Å—Å—ã–ª–æ–∫, –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤, —É—Ä–æ–≤–Ω–µ–π.",
    "",
    "–†–µ–∂–∏–º: Trader. –ú–∞–∫—Å–∏–º—É–º –ø—Ä–∞–∫—Ç–∏–∫–∏, –º–∏–Ω–∏–º—É–º –≤–æ–¥—ã.",
    "–ù–µ —Ä–∞–∑–¥—É–≤–∞–π —Ç–µ–∫—Å—Ç: –∫–∞–∂–¥—ã–π –ø—É–Ω–∫—Ç 1 —Å—Ç—Ä–æ–∫–∞.",
    "",
    styleRule,
    `–ê–∫—Ç–∏–≤: ${assetLabel} (${ticker})`,
    `–ì–æ—Ä–∏–∑–æ–Ω—Ç: ${horizon}`,
    "",
    "–°–¢–†–£–ö–¢–£–†–ê (—Å—Ç—Ä–æ–≥–æ):",
    "üî• –ö–õ–Æ–ß–ï–í–´–ï –°–û–ë–´–¢–ò–Ø",
    "‚Ä¢ –†–û–í–ù–û 2‚Äì3 –ø—É–Ω–∫—Ç–∞, 1 —Å—Ç—Ä–æ–∫–∞ –∫–∞–∂–¥—ã–π",
    "",
    "üìä –ú–ê–ö–†–û-–ö–û–ù–¢–ï–ö–°–¢",
    "‚Ä¢ –†–û–í–ù–û 2‚Äì3 —Ç–µ–∑–∏—Å–∞, 1 —Å—Ç—Ä–æ–∫–∞ –∫–∞–∂–¥—ã–π",
    "",
    "üéØ –°–¶–ï–ù–ê–†–ò–ò",
    "Base: 1 —Å—Ç—Ä–æ–∫–∞ (—É—Å–ª–æ–≤–∏–µ ‚Üí —Ä–µ–∞–∫—Ü–∏—è ‚Üí –ø—Ä–∏—á–∏–Ω–∞)",
    "Bull: 1 —Å—Ç—Ä–æ–∫–∞",
    "Bear: 1 —Å—Ç—Ä–æ–∫–∞",
    "",
    "‚ö†Ô∏è –†–ò–°–ö–ò",
    "‚Ä¢ –†–û–í–ù–û 3‚Äì4 –ø—É–Ω–∫—Ç–∞, 1 —Å—Ç—Ä–æ–∫–∞ –∫–∞–∂–¥—ã–π",
    "",
    "üß† TL;DR",
    "‚Ä¢ –†–û–í–ù–û 2‚Äì3 –ø—É–Ω–∫—Ç–∞, 1 —Å—Ç—Ä–æ–∫–∞ –∫–∞–∂–¥—ã–π",
    "",
    "–í –∫–æ–Ω—Ü–µ –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: END"
  ].join("\n");
}

/* =========================
   Output cleanup
========================= */
function ruCleanup(text) {
  const pairs = [
    [/payrolls/gi, "–∑–∞–Ω—è—Ç–æ—Å—Ç—å –≤ –°–®–ê"],
    [/\bcut\b/gi, "—Å–Ω–∏–∂–µ–Ω–∏–µ —Å—Ç–∞–≤–∫–∏"],
    [/earnings/gi, "–æ—Ç—á—ë—Ç–Ω–æ—Å—Ç—å –∫–æ–º–ø–∞–Ω–∏–π"],
    [/guidance/gi, "–ø—Ä–æ–≥–Ω–æ–∑ –º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞"],
    [/risk[-\s]?on/gi, "–∞–ø–ø–µ—Ç–∏—Ç –∫ —Ä–∏—Å–∫—É"],
    [/risk[-\s]?off/gi, "—É—Ö–æ–¥ –æ—Ç —Ä–∏—Å–∫–∞"],
    [/hawkish/gi, "–∂—ë—Å—Ç–∫–∏–π —Ç–æ–Ω"],
    [/dovish/gi, "–º—è–≥–∫–∏–π —Ç–æ–Ω"],
    [/minutes/gi, "–ø—Ä–æ—Ç–æ–∫–æ–ª –∑–∞—Å–µ–¥–∞–Ω–∏—è"],
    [/\byoy\b/gi, "–≥/–≥"],
    [/\bbp\b/gi, "–±.–ø."]
  ];

  let out = String(text || "");
  for (let i = 0; i < pairs.length; i++) out = out.replace(pairs[i][0], pairs[i][1]);
  return out;
}

function stripFormattingArtifacts(text) {
  let out = String(text || "");
  out = out.split("**").join("");
  out = out.split("__").join("");
  out = out.split("*").join("");
  out = out.split("`").join("");
  return out;
}

function normalizeForTelegram(s) {
  return String(s || "").replace(/\r\n/g, "\n").replace(/\u0000/g, "").trim();
}

/* =========================
   Telegram API
========================= */
async function tgApi(method, body) {
  const token = globalThis.TELEGRAM_BOT_TOKEN;
  if (!token) throw new Error("TELEGRAM_BOT_TOKEN is not set");

  const url = "https://api.telegram.org/bot" + token + "/" + method;

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const t = await safeText(res);
    throw new Error("Telegram " + method + " failed: " + res.status + " " + t);
  }
  return res.json().catch(() => ({}));
}

async function tgSendMessage(chatId, text, parseMode, replyMarkup) {
  return tgApi("sendMessage", {
    chat_id: chatId,
    text: text,
    parse_mode: parseMode,
    disable_web_page_preview: true,
    reply_markup: replyMarkup
  });
}

async function tgSendLongMessage(chatId, text) {
  const chunks = splitTelegram(text, 3500);
  for (let i = 0; i < chunks.length; i++) {
    await tgSendMessage(chatId, chunks[i], PARSE_MODE, assetsReplyKeyboard());
  }
}

function splitTelegram(text, maxLen) {
  const out = [];
  let t = String(text || "");

  while (t.length > maxLen) {
    let cut = t.lastIndexOf("\n", maxLen);
    if (cut < 1200) cut = maxLen;
    out.push(t.slice(0, cut));
    t = t.slice(cut);
  }
  if (t.trim().length) out.push(t);
  return out;
}

async function safeText(res) {
  try {
    return (await res.text()).slice(0, 800);
  } catch {
    return "";
  }
}
